import * as eth from "ethers";

import { applyColors } from "./cards";
import { Deck, DeckData } from "./types";

export const getRuneDeck = (): Deck => applyColors(JSON.parse(JSON.stringify([

  ////////////////////////////////////////
  // Rune Prefixes
  ////////////////////////////////////////

  {
    front: "|",
    backTitle: "bar",
    backDescription: "rune prefix for core expressions",
  },

  {
    front: "$",
    backTitle: "buc",
    backDescription: "rune prefix for structures",
  },

  {
    front: "%",
    backTitle: "cen",
    backDescription: "rune prefix for calls and samples",
  },

  {
    front: ":",
    backTitle: "col",
    backDescription: "rune prefix for cells",
  },

  {
    front: ".",
    backTitle: "dot",
    backDescription: "rune prefix for nock evaluations",
  },

  {
    front: "^",
    backTitle: "ket",
    backDescription: "rune prefix for type casting",
  },

  {
    front: "~",
    backTitle: "sig",
    backDescription: "rune prefix for interpreter hints",
  },

  {
    front: ";",
    backTitle: "mic",
    backDescription: "rune prefix for macros",
  },

  {
    front: "=",
    backTitle: "tis",
    backDescription: "rune prefix for subject modification",
  },

  {
    front: "?",
    backTitle: "wut",
    backDescription: "rune prefix for conditionals",
  },

  {
    front: "!",
    backTitle: "zap",
    backDescription: "rune prefix for wildcards",
  },

  {
    front: "/",
    backTitle: "fas",
    backDescription: "rune prefix for build operations eg imports",
  },

  {
    front: "+",
    backTitle: "lus",
    backDescription: "rune prefix for arm definitions",
  },

  ////////////////////////////////////////
  // Other Symbol Names
  ////////////////////////////////////////

  {
    front: "␣",
    backTitle: "ace",
    backDescription: "separates wide code",
  },

  {
    front: "␣␣ or \\n",
    backTitle: "gap",
    backDescription: "separates tall code",
  },

  {
    front: "-",
    backTitle: "hep",
    backDescription: "",
  },

  {
    front: "_",
    backTitle: "cab",
    backDescription: "",
  },

  {
    front: "\\",
    backTitle: "bas",
    backDescription: "",
  },

  {
    front: ",",
    backTitle: "com",
    backDescription: "",
  },
  {
    front: "*",
    backTitle: "tar",
    backDescription: "",
  },

  {
    front: "#",
    backTitle: "hax",
    backDescription: "",
  },

  {
    front: "&",
    backTitle: "pam",
    backDescription: "",
  },

  {
    front: "@",
    backTitle: "pat",
    backDescription: "prefix for auras aka types",
  },

  {
    front: "'",
    backTitle: "soq",
    backDescription: "",
  },


  {
    front: "`",
    backTitle: "tic",
    backDescription: "",
  },

  {
    front: "\"",
    backTitle: "doq",
    backDescription: "",
  },

  {
    front: ")",
    backTitle: "par",
    backDescription: "",
  },

  {
    front: "(",
    backTitle: "pal",
    backDescription: "",
  },

  {
    front: ">",
    backTitle: "gar",
    backDescription: "",
  },

  {
    front: "<",
    backTitle: "gal",
    backDescription: "",
  },

  {
    front: "}",
    backTitle: "ker",
    backDescription: "",
  },

  {
    front: "{",
    backTitle: "kel",
    backDescription: "",
  },

  {
    front: "]",
    backTitle: "ser",
    backDescription: "",
  },

  {
    front: "[",
    backTitle: "sel",
    backDescription: "",
  },

  ////////////////////////////////////////
  // Hoon Runes
  // In order of frequency in base desk
  // Order generated by get-rune-freq.sh
  ////////////////////////////////////////

  {
    front: "::",
    backTitle: "colcol",
    backDescription: "comment for in-line code documentation",
  },

  {
    front: "++",
    backTitle: "luslus",
    backDescription: "produce a normal arm",
  },

  {
    front: "=/",
    backTitle: "tisfas",
    backDescription: "combine a named noun with the subject",
  },

  {
    front: "|=",
    backTitle: "bartis",
    backDescription: "produce a dry gate",
  },

  {
    front: "^-",
    backTitle: "kethep",
    backDescription: "cast to type according to explicit label",
  },

  {
    front: "^+",
    backTitle: "ketlus",
    backDescription: "typecast by inferred type (a fence)",
  },

  {
    front: "==",
    backTitle: "tistis",
    backDescription: "terminate series of hoon expressions",
  },

  {
    front: "?:",
    backTitle: "wutcol",
    backDescription: "branch on boolean test",
  },

  {
    front: "%+",
    backTitle: "cenlus",
    backDescription: "call a gate with a cell sample",
  },

  {
    front: "?~",
    backTitle: "wutsig",
    backDescription: "branch on whether a wing of the subject is null",
  },

  {
    front: "?!",
    backTitle: "wutzap",
    backDescription: "logical NOT, boolean",
  },

  {
    front: "?=",
    backTitle: "wuttis",
    backDescription: "test pattern match",
  },

  {
    front: "?#",
    backTitle: "wuthax",
    backDescription: "test pattern match",
  },

  {
    front: "?+",
    backTitle: "wutlus",
    backDescription: "switch against a union, with default",
  },

  {
    front: "--",
    backTitle: "hephep",
    backDescription: "terminate core expression",
  },

  {
    front: "+$",
    backTitle: "lusbuc",
    backDescription: "produce a structure arm (type definition)",
  },

  {
    front: ";~",
    backTitle: "micsig",
    backDescription: "glue pipeline together with product-sample adapter (monadic bind)",
  },

  {
    front: ";+",
    backTitle: "miclus",
    backDescription: "(sail) make a single xml node",
  },

  {
    front: ";*",
    backTitle: "mictar",
    backDescription: "(sail) make a list of xml nodes from hoon expression",
  },

  {
    front: "%-",
    backTitle: "cenhep",
    backDescription: "call a gate",
  },

  {
    front: ":-",
    backTitle: "colhep",
    backDescription: "construct a cell, 2-tuple",
  },

  {
    front: "?.",
    backTitle: "wutdot",
    backDescription: "inverted branch on boolean test",
  },

  {
    front: "|-",
    backTitle: "barhep",
    backDescription: "produce a trap aka loop (core with one arm) and evaluate it",
  },

  {
    front: "=.",
    backTitle: "tisdot",
    backDescription: "change one leg in the subject",
  },

  {
    front: "=*",
    backTitle: "tistar",
    backDescription: "define an alias",
  },

  {
    front: "|%",
    backTitle: "barcen",
    backDescription: "produce a core (battery and payload)",
  },

  {
    front: "=^",
    backTitle: "tisket",
    backDescription: "pin the head of a pair; change the leg with the tail",
  },

  {
    front: "=?",
    backTitle: "tiswut",
    backDescription: "change one leg of the subject conditionally",
  },

  {
    front: "=|",
    backTitle: "tisbar",
    backDescription: "combine default type value with the subject",
  },

  {
    front: "$:",
    backTitle: "buccol",
    backDescription: "form a cell type (tuple)",
  },

  {
    front: "|*",
    backTitle: "bartar",
    backDescription: "produce a wet gate",
  },

  {
    front: "?-",
    backTitle: "wuthep",
    backDescription: "switch against a union (no default)",
  },

  {
    front: ":~",
    backTitle: "colsig",
    backDescription: "construct a null terminated list",
  },

  {
    front: ":_",
    backTitle: "colcab",
    backDescription: "construct a cell, inverted",
  },

  {
    front: "$%",
    backTitle: "buccen",
    backDescription: "structure that recognizes a union tagged by head atom (eg list of named parameters)",
  },

  {
    front: "=,",
    backTitle: "tiscom",
    backDescription: "expose namespace & define a bridge",
  },

  {
    front: "=+",
    backTitle: "tislus",
    backDescription: "combine a new noun with the subject",
  },

  {
    front: "=~",
    backTitle: "tissig",
    backDescription: "compose many expressions",
  },

  {
    front: ".^",
    backTitle: "dotket",
    backDescription: "scry aka load from namespace using nock 12",
  },

  {
    front: "=-",
    backTitle: "tishep",
    backDescription: "combine a new noun with the subject",
  },

  {
    front: "~&",
    backTitle: "sigpam",
    backDescription: "print (debugging tool)",
  },

  {
    front: ";<",
    backTitle: "micgal",
    backDescription: "glue a pipeline together (monadic bind)",
  },

  {
    front: "$-",
    backTitle: "buchep",
    backDescription: "structure that normalizes to an example gate",
  },

  {
    front: "|_",
    backTitle: "barcab",
    backDescription: "produce a door",
  },

  {
    front: ".+",
    backTitle: "dotlus",
    backDescription: "increment an atom using Nock 4",
  },

  {
    front: "|.",
    backTitle: "bardot",
    backDescription: "produce a trap (a core with one arm)",
  },

  {
    front: "%=",
    backTitle: "centis",
    backDescription: "resolve a wing with changes",
  },

  {
    front: "^=",
    backTitle: "kettis",
    backDescription: "bind name to a value",
  },

  {
    front: "^?",
    backTitle: "ketwut",
    backDescription: "convert a core to a lead core (bivariant)",
  },

  {
    front: "^|",
    backTitle: "ketbar",
    backDescription: "convert a gold core to an iron core (invariant)",
  },

  {
    front: "?^",
    backTitle: "wutket",
    backDescription: "branch on whether a wing of the subject is a cell",
  },

  {
    front: "?|",
    backTitle: "wutbar",
    backDescription: "logical OR (boolean)",
  },

  {
    front: "|^",
    backTitle: "barket",
    backDescription: "produce a core whose battery includes a $ arm and computes the later",
  },

  {
    front: "=<",
    backTitle: "tisgal",
    backDescription: "compose two expressions, inverted",
  },

  {
    front: "=>",
    backTitle: "tisgar",
    backDescription: "compose two expressions",
  },

  {
    front: "~_",
    backTitle: "sigcab",
    backDescription: "print in stack trace, user-formatted",
  },

  {
    front: ":*",
    backTitle: "coltar",
    backDescription: "construct a cell, n-tuple",
  },

  {
    front: "!<",
    backTitle: "zapgal",
    backDescription: "lift dynamic value into static context",
  },

  {
    front: "!>",
    backTitle: "zapgar",
    backDescription: "wrap a noun in its type",
  },

  {
    front: "%.",
    backTitle: "cendot",
    backDescription: "call a gate, inverted",
  },

  {
    front: "!=",
    backTitle: "zaptis",
    backDescription: "make the Nock formula for a hoon expression",
  },

  {
    front: "?@",
    backTitle: "wutpat",
    backDescription: "branch on whether a wing of the subject is an atom",
  },

  {
    front: "$@",
    backTitle: "bucpat",
    backDescription: "structure that normalizes a union tagged by head atom",
  },

  {
    front: "~%",
    backTitle: "sigcen",
    backDescription: "register jet",
  },

  {
    front: "~/",
    backTitle: "sigfas",
    backDescription: "register jet with registered context",
  },

  {
    front: "=;",
    backTitle: "tismic",
    backDescription: "combine a named noun with the subject, inverted",
  },

  {
    front: ";;",
    backTitle: "micmic",
    backDescription: "normalize with a mold, asserting fixpoint",
  },

  {
    front: ":^",
    backTitle: "colket",
    backDescription: "construct a cell, 4-tuple",
  },

  {
    front: ":+",
    backTitle: "collus",
    backDescription: "construct a cell, 3-tuple",
  },

  {
    front: "/-",
    backTitle: "fashep",
    backDescription: "import a file from the sur directory",
  },

  {
    front: "/+",
    backTitle: "faslus",
    backDescription: "import a file from the lib directory",
  },

  {
    front: "|~",
    backTitle: "barsig",
    backDescription: "produce an iron gate",
  },

  {
    front: "~?",
    backTitle: "sigwut",
    backDescription: "print conditionally (for debugging)",
  },

  {
    front: "=:",
    backTitle: "tiscol",
    backDescription: "change multiple legs in the subject",
  },

  {
    front: "%^",
    backTitle: "cenket",
    backDescription: "call a gate with triple sample",
  },

  {
    front: "$?",
    backTitle: "bucwut",
    backDescription: "form a type from a union of other types",
  },

  {
    front: "|?",
    backTitle: "barwut",
    backDescription: "produce a lead trap",
  },

  {
    front: "$~",
    backTitle: "bucsig",
    backDescription: "define a custom type default value",
  },

  {
    front: ";:",
    backTitle: "miccol",
    backDescription: "call a binary function as an n-ary function",
  },

  {
    front: ";/",
    backTitle: "micfas",
    backDescription: "(sail) yield type as xml element",
  },

  {
    front: "/?",
    backTitle: "faswut",
    backDescription: "pin a version number",
  },

  {
    front: "%_",
    backTitle: "cencab",
    backDescription: "resolve a sing with changes, preserving type",
  },

  {
    front: ".*",
    backTitle: "dottar",
    backDescription: "evaluate using Nock 2",
  },

  {
    front: "|@",
    backTitle: "barpat",
    backDescription: "produce a wet core (battery and payload)",
  },

  {
    front: "/~",
    backTitle: "fassig",
    backDescription: "import contents of a directory under face=(map @ta type)",
  },

  {
    front: "?<",
    backTitle: "wutgal",
    backDescription: "negative assertion",
  },

  {
    front: "?>",
    backTitle: "wutgar",
    backDescription: "positive assertion",
  },

  {
    front: "+*",
    backTitle: "lustar",
    backDescription: "produce a type constructor arm",
  },

  {
    front: "+|",
    backTitle: "lusbar",
    backDescription: "label a chapter (produces no arm)",
  },

  {
    front: "^.",
    backTitle: "ketdot",
    backDescription: "typecast on value",
  },

  {
    front: "$=",
    backTitle: "buctis",
    backDescription: "structure that wraps a face around another structure",
  },

  {
    front: "!.",
    backTitle: "zapdot",
    backDescription: "turn off stack trace",
  },

  {
    front: "%*",
    backTitle: "centar",
    backDescription: "evaluate an expression, then resolves a wing with changes",
  },

  {
    front: "%:",
    backTitle: "cencol",
    backDescription: "call a gate with many arguments",
  },

  {
    front: ".=",
    backTitle: "dottis",
    backDescription: "test for equality using Nock 5",
  },

  {
    front: "$^",
    backTitle: "bucket",
    backDescription: "structure that normalizes to a union tagged by head depth (cell)",
  },

  {
    front: "|:",
    backTitle: "barcol",
    backDescription: "produce a gate with a custom sample",
  },

  {
    front: "+&",
    backTitle: "luspam",
    backDescription: "logical AND, boolean",
  },

  {
    front: "!:",
    backTitle: "zapcol",
    backDescription: "turn on stack trace",
  },

  {
    front: "/%",
    backTitle: "fascen",
    backDescription: "import mark definition from mar directory",
  },

  {
    front: "%~",
    backTitle: "censig",
    backDescription: "evaluate an arm in a door",
  },

  {
    front: "$_",
    backTitle: "buccab",
    backDescription: "structure that normalizes to an example",
  },

  {
    front: "!?",
    backTitle: "zapwut",
    backDescription: "restrict hoon kelvin version",
  },

  {
    front: "^~",
    backTitle: "ketsig",
    backDescription: "fold constant at compile time",
  },

  {
    front: ".?",
    backTitle: "dotwut",
    backDescription: "test for cell or atom using Nock 3",
  },

  {
    front: "$<",
    backTitle: "bucgal",
    backDescription: "structure from filter (excluding)",
  },

  {
    front: "$>",
    backTitle: "bucgar",
    backDescription: "structure from filter (requiring)",
  },

  {
    front: "$|",
    backTitle: "bucbar",
    backDescription: "structure with verification",
  },

  {
    front: "/$",
    backTitle: "fasbuc",
    backDescription: "import mark conversion gate from mar directory",
  },

  {
    front: "/=",
    backTitle: "fastis",
    backDescription: "import results of user-specificed path wrapped in face",
  },

  {
    front: "!,",
    backTitle: "zapcom",
    backDescription: "emit AST of expression",
  },

  {
    front: "!!",
    backTitle: "zapzap",
    backDescription: "crash",
  },

  {
    front: "$.",
    backTitle: "bucdot",
    backDescription: "structure as read-write core",
  },

  {
    front: "$&",
    backTitle: "bucpam",
    backDescription: "repaired structure",
  },

  {
    front: "~|",
    backTitle: "sigbar",
    backDescription: "print in stack trace if failure",
  },

  {
    front: "~<",
    backTitle: "siggal",
    backDescription: "raw hint, applied to product aka backward",
  },

  {
    front: "~>",
    backTitle: "siggar",
    backDescription: "raw hint, applied to computation aka foreward",
  },

  {
    front: "~+",
    backTitle: "siglus",
    backDescription: "cache computation",
  },

  {
    front: "^:",
    backTitle: "ketcol",
    backDescription: "produce a factory gate for a type (switch from regular parsing to spec/type parsing)",
  },

  {
    front: "^*",
    backTitle: "kettar",
    backDescription: "bunt, produces default mold value",
  },

  {
    front: "~$",
    backTitle: "sigbuc",
    backDescription: "profiler hit counter",
  },

  {
    front: "~=",
    backTitle: "sigtis",
    backDescription: "detect duplicate",
  },

  {
    front: "~!",
    backTitle: "sigzap",
    backDescription: "print type if compilation fail",
  },

  {
    front: "^&",
    backTitle: "ketpam",
    backDescription: "convert a core to a zinc core",
  },

  {
    front: "/*",
    backTitle: "fastar",
    backDescription: "import the contents of a file in the desk converted to a mark (build-time static data)",
  },

  {
    front: "!@",
    backTitle: "zappat",
    backDescription: "evauluate conditional on existence of wing",
  },

  {
    front: "!;",
    backTitle: "zapmic",
    backDescription: "emit the type for an expression using the type of type",
  },

  {
    front: "$,",
    backTitle: "buccol",
    backDescription: "form a cell type (tuple)",
  },

  {
    front: "$*",
    backTitle: "buctar",
    backDescription: "bunt a value (profice default empty value)",
  },

  {
    front: "$;",
    backTitle: "bucmic",
    backDescription: "manual structure",
  },

  {
    front: ";=",
    backTitle: "mictis",
    backDescription: "(sail) make a list of xml nodes",
  },

  ////////////////////////////////////////
  // Urbit Vocab
  ////////////////////////////////////////

  {
    front: "bridge",
    backTitle: "Azimuth client",
    backDescription: "interface to the urbit id registry",
  },

  {
    front: "mold",
    backTitle: "types",
    backDescription: "type definition + a function for coercing data to the type",
  },

  {
    front: "core",
    backTitle: "cell of battery + payload",
    backDescription: "similar to methods + data of OOP objects",
  },

  {
    front: "cell",
    backTitle: "tuple",
    backDescription: "ordered pair of nouns eg [12 23]",
  },

  {
    front: "wing",
    backTitle: "limb aka arm or leg",
    backDescription: "piece of data or code that can be referenced in the subject",
  },

  {
    front: "arm",
    backTitle: "named hoon expression",
    backDescription: "",
  },

  {
    front: "leg",
    backTitle: "named data",
    backDescription: "",
  },

  ////////////////////////////////////////
  // Other Non-Rune Symbols
  ////////////////////////////////////////

  {
    front: "+<",
    backTitle: "lusgal",
    backDescription: "seems to be a type annotation or something?",
  },

  {
    front: "%&",
    backTitle: "cenpam",
    backDescription: "appears to be some kind of type annotation?",
  },

  {
    front: "%$",
    backTitle: "cenbuc",
    backDescription: "type annotation?",
  },

  {
    front: "^$",
    backTitle: "ketbuc",
    backDescription: "unknown",
  },

  {
    front: ".$",
    backTitle: "dotbuc",
    backDescription: "unknown",
  },

  {
    front: "?&",
    backTitle: "wutpam",
    backDescription: "",
  },

  {
    front: "=~",
    backTitle: "tissig",
    backDescription: "",
  },

  {
    front: "^?",
    backTitle: "ketwut",
    backDescription: "",
  },

  {
    front: "-:",
    backTitle: "hepcol",
    backDescription: "",
  },

  {
    front: "+:",
    backTitle: "luscol",
    backDescription: "",
  },

  {
    front: ".-",
    backTitle: "dothep",
    backDescription: "",
  },

  {
    front: "=%",
    backTitle: "tiscen",
    backDescription: "",
  },

  {
    front: ":$",
    backTitle: "colbuc",
    backDescription: "",
  },

  {
    front: "~,",
    backTitle: "sigcom",
    backDescription: "",
  },

  {
    front: "~.",
    backTitle: "sigdot",
    backDescription: "",
  },

  {
    front: "-<",
    backTitle: "hepgal",
    backDescription: "",
  },

  {
    front: "=&",
    backTitle: "tispam",
    backDescription: "",
  },

  {
    front: "/;",
    backTitle: "fasmic",
    backDescription: "",
  },

  {
    front: "??",
    backTitle: "wutwut",
    backDescription: "",
  },

  {
    front: "-$",
    backTitle: "hepbuc",
    backDescription: "",
  },

  {
    front: ":.",
    backTitle: "coldot",
    backDescription: "",
  },

  {
    front: "+-",
    backTitle: "lushep",
    backDescription: "",
  },

  {
    front: "+~",
    backTitle: "lussig",
    backDescription: "",
  },

  {
    front: "$$",
    backTitle: "bucbuc",
    backDescription: "",
  },

  {
    front: "$;",
    backTitle: "bucbuc",
    backDescription: "",
  },

  {
    front: "~~",
    backTitle: "sigsig",
    backDescription: "",
  },

  {
    front: "~:",
    backTitle: "sigcol",
    backDescription: "",
  },

  {
    front: "|,",
    backTitle: "barcom",
    backDescription: "",
  },

  {
    front: ":?",
    backTitle: "colwut",
    backDescription: "",
  },

  {
    front: "-,",
    backTitle: "hepcom",
    backDescription: "",
  },

  {
    front: "+?",
    backTitle: "luswut",
    backDescription: "",
  },

  {
    front: "|?",
    backTitle: "barwut",
    backDescription: "",
  },

  {
    front: "^^",
    backTitle: "ketket",
    backDescription: "",
  },

  {
    front: "^%",
    backTitle: "ketcen",
    backDescription: "",
  },

  {
    front: ":=",
    backTitle: "coltis",
    backDescription: "",
  },

  {
    front: ":%",
    backTitle: "colcen",
    backDescription: "",
  },

  {
    front: ".,",
    backTitle: "dotcom",
    backDescription: "",
  },

  {
    front: "~-",
    backTitle: "sighep",
    backDescription: "",
  },

  {
    front: ";-",
    backTitle: "michep",
    backDescription: "",
  },

  {
    front: ":<",
    backTitle: "colgal",
    backDescription: "",
  },

  {
    front: ".:",
    backTitle: "dotcol",
    backDescription: "",
  },

  {
    front: ".&",
    backTitle: "dotpam",
    backDescription: "",
  },

  {
    front: "-~",
    backTitle: "hepsig",
    backDescription: "",
  },

  {
    front: "!-",
    backTitle: "zaphep",
    backDescription: "",
  },

  {
    front: "!&",
    backTitle: "zappam",
    backDescription: "",
  },

  {
    front: "^_",
    backTitle: "ketcab",
    backDescription: "",
  },

  {
    front: "^,",
    backTitle: "ketcom",
    backDescription: "",
  },

  {
    front: "?,",
    backTitle: "wutcom",
    backDescription: "",
  },

  {
    front: "?%",
    backTitle: "wutcen",
    backDescription: "",
  },

  {
    front: ";,",
    backTitle: "miccom",
    backDescription: "",
  },

  {
    front: ":;",
    backTitle: "colmic",
    backDescription: "",
  },

  {
    front: ":,",
    backTitle: "colcom",
    backDescription: "",
  },

  {
    front: "/_",
    backTitle: "fascab",
    backDescription: "",
  },

  {
    front: "/.",
    backTitle: "fasdot",
    backDescription: "",
  },

  {
    front: "/,",
    backTitle: "fascom",
    backDescription: "",
  },

  {
    front: ".~",
    backTitle: "dotsig",
    backDescription: "",
  },

  {
    front: "-_",
    backTitle: "hepcab",
    backDescription: "",
  },

  {
    front: "+,",
    backTitle: "luscom",
    backDescription: "",
  },

  {
    front: "%;",
    backTitle: "cenmic",
    backDescription: "",
  },

  {
    front: "%,",
    backTitle: "cencom",
    backDescription: "",
  },

])) as DeckData)
